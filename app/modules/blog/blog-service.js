angular.module('webApp')
  .constant('blogServiceConstants', {
    defaultChannelName: 'Basic Subscription',
    defaultChannelDescription: 'Exclusive News Feed\nEarly Updates on New Releases',
    defaultBlogIntroduction: 'Welcome to my new exclusive series. More of your favourites released every week, available to subscribers only.'
  })
  .factory('blogService',
  function($rootScope, $q, blogStub, aggregateUserState, authenticationService, blogRepositoryFactory, blogServiceConstants) {
    'use strict';

    var service = Object.create({}, {
      blogId: { get: function () { return (aggregateUserState.currentValue && aggregateUserState.currentValue.creatorStatus) ? aggregateUserState.currentValue.creatorStatus.blogId : null; }},
      hasBlog: { get: function () { return service.blogId !== null; }}
    });

    service.createFirstBlog = function(blogData) {
      if (service.hasBlog) {
        return $q.reject(new FifthweekError('Blog already created'));
      }

      // We need to store the user ID before posting the new blog data
      // because it could change during the call.
      var blogUserId = authenticationService.currentUser.userId;
      var blogRepository = blogRepositoryFactory.forCurrentUser();
      return blogStub.postBlog(blogData)
        .then(function(response) {
          var blogId = response.data;
          var channels = [
            {
              channelId: blogId,
              price: blogData.basePrice,
              isDefault: true,
              isVisibleToNonSubscribers: true,
              collections: [],

              // These constants are repeated client-side to avoid an API round-trip. Consequences of these
              // becoming inconsistent with those generated by the API are low, and contacting the server to
              // retrieve static information seems excessive.
              name: blogServiceConstants.defaultChannelName,
              description: blogServiceConstants.defaultChannelDescription
            }
          ];

          aggregateUserState.setDelta(blogUserId, 'creatorStatus', {blogId: blogId});

          var localBlog = _.cloneDeep(blogData);
          localBlog.blogId = blogId;
          delete localBlog.basePrice;
          localBlog.introduction = blogServiceConstants.defaultBlogIntroduction;
          localBlog.creationDate = new Date();
          localBlog.channels = channels;
          return blogRepository.setBlog(localBlog);
      });
    };

    return service;
  }
);
