angular.module('webApp')
  .constant('subscriptionServiceConstants', {
    defaultChannelName: 'Basic Subscription',
    defaultChannelDescription: 'Exclusive News Feed\nEarly Updates on New Releases',
    defaultSubscriptionIntroduction: 'Welcome to my new exclusive series. More of your favourites released every week, available to subscribers only.'
  })
  .factory('subscriptionService',
  function($rootScope, $q, subscriptionStub, aggregateUserState, authenticationService, subscriptionRepositoryFactory, subscriptionServiceConstants) {
    'use strict';

    var service = Object.create({}, {
      subscriptionId: { get: function () { return (aggregateUserState.currentValue && aggregateUserState.currentValue.creatorStatus) ? aggregateUserState.currentValue.creatorStatus.subscriptionId : null; }},
      hasSubscription: { get: function () { return service.subscriptionId !== null; }}
    });

    service.createFirstSubscription = function(subscriptionData) {
      if (service.hasSubscription) {
        return $q.reject(new FifthweekError('Subscription already created'));
      }

      // We need to store the user ID before posting the new subscription data
      // because it could change during the call.
      var subscriptionUserId = authenticationService.currentUser.userId;
      var subscriptionRepository = subscriptionRepositoryFactory.forCurrentUser();
      return subscriptionStub.postSubscription(subscriptionData)
        .then(function(response) {
          var subscriptionId = response.data;
          var channels = [
            {
              channelId: subscriptionId,
              priceInUsCentsPerWeek: subscriptionData.basePrice,
              isDefault: true,
              collections: [],

              // These constants are repeated client-side to avoid an API round-trip. Consequences of these
              // becoming inconsistent with those generated by the API are low, and contacting the server to
              // retrieve static information seems excessive.
              name: subscriptionServiceConstants.defaultChannelName,
              description: subscriptionServiceConstants.defaultChannelDescription
            }
          ];

          aggregateUserState.setDelta(subscriptionUserId, 'creatorStatus', {subscriptionId: subscriptionId});
          aggregateUserState.setDelta(subscriptionUserId, 'createdChannelsAndCollections', {channels: channels});

          var localSubscription = _.cloneDeep(subscriptionData);
          localSubscription.subscriptionId = subscriptionId;
          localSubscription.creatorId = subscriptionUserId;
          delete localSubscription.basePrice;
          localSubscription.introduction = subscriptionServiceConstants.defaultSubscriptionIntroduction;
          localSubscription.creationDate = new Date();
          return subscriptionRepository.setSubscription(localSubscription);
      });
    };

    return service;
  }
);
